
```
# Skyscraper プロジェクト憲法 (v4.0)

あなたは、FlutterとDartの熟練エキスパートです。これから、Blueskyのクライアントアプリ「Skyscraper」を開発します。以下の仕様を厳密に守り、最高品質のコードを生成してください。

---

### 第1章: プロジェクト概要 (Project Overview)

#### 1.1. 目的
- Bluesky公式アプリの主要機能を網羅し、リッチなUIを持つ、実際に動作するクロスプラットフォームアプリを開発する。
- 高い保守性と拡張性を持ち、テストが容易なコードベースを構築する。

#### 1.2. リポジトリ
- `https://github.com/Nyao0410/Skyscraper_project`

#### 1.3. 開発スコープ
- **MVP (v0.4.x) の定義**: **ログインして、自分のタイムラインを閲覧できること。**
- **v1.0.0 での目標機能リスト**:
    - **表示系**: タイムライン、投稿詳細（スレッド）、通知一覧、プロフィール
    - **投稿系**: テキスト投稿、画像投稿（4枚まで）、リプライ、引用リポスト
    - **インタラクション系**: いいね、リポスト、フォロー/アンフォロー
    - **検索系**: ユーザー検索

---

### 第2章: 技術選定 (Technology Stack)

#### 2.1. 主要技術
- **フレームワーク**: Flutter 3.x, Dart 3.x
- **状態管理**: **Riverpod (`flutter_riverpod`)** を全面的に採用する。
- **API連携**: **`package:bluesky`** を使用する。
- **データモデル**: **`package:freezed`** を使用する。
- **ナビゲーション**: **`package:go_router`** を使用。
- **静的解析**: **`package:very_good_analysis`** を導入。

#### 2.2. パッケージバージョン管理
- **原則**: `pubspec.yaml`に記述するバージョンは`^`（キャレット）を使用せず、`1.0.0`のように**具体的なバージョン番号に固定する。**
- **更新プロセス**: パッケージの更新は、必ず影響調査とテストを専用ブランチで行う。

---

### 第3章: アーキテクチャ設計 (Architectural Design)

#### 3.1. 基本アーキテクチャ
- 依存関係は原則として `UI (screens/widgets) -> Provider -> Repository -> API` の一方向とする。
- **内部モデルへの変換**: `Repository`層で、外部APIのモデルからアプリ内部で使用する`freezed`モデルへの変換を責務として行う。

#### 3.2. 設計原則
- **UIとロジックの分離**: 開発を「コアロジック層」と「UIプレゼンテーション層」の2フェーズに明確に分離する。
- **保守性**: 全ての公開クラス・メソッドにはDartDocコメントを記述する。

---

### 第4章: 開発ワークフロー (Development Workflow)

#### 4.1. ブランチ戦略
- **原則**: GitHub Flowに準拠する (`main`ブランチと機能ブランチ)。
- **命名規則**: 機能ブランチ名は、開発計画書のバージョンと内容が分かるように命名する。(例: `feat/0.2.2-auth-provider`)

#### 4.2. コミット規約
- **原則**: Conventional Commits規約に準拠する。(例: `feat:`, `fix:`, `docs:`)

#### 4.3. ドキュメンテーション
- `CHANGELOG.md`に各バージョンの変更点を記録する。
- エラー修正の過程を`REPORT.md`に記録する。

#### 4.4. CI/CD (継続的インテグレーション/デリバリー)
- GitHub Actionsなどを利用し、テストとビルドの自動化パイプラインを構築する。

---

### 第5章: 品質保証 (Quality Assurance)

#### 5.1. テスト戦略
- **テスト駆動**: `Repository`, `Provider`層は、原則としてユニットテストを先に記述する。
- **モック化**: ユニットテストでは外部依存（APIクライアント等）を`mockito`でモック化する。

#### 5.2. コード生成に関する規約
- **依存関係の徹底**: 互換性が確認された安定した組み合わせを調査し、バージョンを固定する。
- **最小再現ケースでの検証 (サンドボックス戦略)**: 新しいモデルやAPIの利用は、まずサンドボックス・プロジェクトで検証する。
- **限界の認識**: 複雑すぎる場合は、手動でのモデル実装に切り替える。

#### 5.3. デバッグ戦略
- **エラー分析**: `build_runner`のログを詳細に分析し、根本原因を特定する。
- **クリーンビルド**: `flutter clean`と`build_runner`を定期的に実行する。
- **情報源**: `pub.dev`のChangelogやAPIリファレンス、GitHubのIssueを常に参照する。

---

### 第6章: 非機能要件 (Non-Functional Requirements)

#### 6.1. UI/UX品質
- **パフォーマンス**: ユーザー操作に対して60fpsを維持し、適切なローディング・エラー表示やアニメーションによるフィードバックを行う。
- **レスポンシブ対応**と**アクセシビリティ(a11y)**を考慮する。
- **オフライン時の挙動**: オフライン状態を検知し、キャッシュされたデータの表示や、適切なメッセージ表示を行う。
- **状態の永続化**: タイムラインのスクロール位置など、ユーザーの状態をある程度保持する。
- **入力データ保護**: 投稿作成中のテキストなどを、下書きとして自動保存する仕組みを検討する。

#### 6.2. 運用・保守
- **APIレートリミット対策**: APIの呼び出し回数制限を超えた場合のエラーハンドリングと、適切なリトライ戦略を実装する。
- **ロギングとクラッシュレポート**: `Firebase Crashlytics`等のツールを導入し、リリース後の問題を追跡できる体制を構築する。
- **リモートコンフィグ / 機能フラグ**: `Firebase Remote Config`などを活用し、アプリのアップデートなしで設定変更や機能のON/OFFができる仕組みを検討する。
```